/****************** packages and imports **************/

package com.pablocompany.practicano1_compi1.compiler.logic;
/*Created by Pablo*/
import java_cup.runtime.*;
import java.util.*;
import com.pablocompany.practicano1_compi1.compiler.models.*;
import com.pablocompany.practicano1_compi1.compiler.models.expresiones.*;
import com.pablocompany.practicano1_compi1.compiler.models.operadores.logicos.*;
import com.pablocompany.practicano1_compi1.compiler.models.operadores.matematicos.*;
import com.pablocompany.practicano1_compi1.compiler.models.operadores.relacionales.*;
import com.pablocompany.practicano1_compi1.compiler.models.enumsprogam.*;
import com.pablocompany.practicano1_compi1.compiler.models.configuracion.*;
import com.pablocompany.practicano1_compi1.compiler.models.estructuras.*;
import com.pablocompany.practicano1_compi1.compiler.models.colores.*;
import com.pablocompany.practicano1_compi1.compiler.models.estrucutrassimples.*;

/*------------------------------------------------------
                        CUP
--------------------------------------------------------*/
parser code {:

       Lexer lex;
       private List<ErrorAnalisis> syntaxErrorList;

       // conexion de parser y lexer
       public Parser(Lexer lex){
           super(lex);
           this.lex = lex;
           syntaxErrorList = new ArrayList<>();
       }

       // Getters
       public Lexer getLexer(){
           return this.lex;
       }

       public List<ErrorAnalisis> getSyntaxErrorList(){
           return this.syntaxErrorList;
       }

        //Metodo que permite retornar los errores sintacticos
        public void syntax_error(Symbol cur_token) {
            List<Integer> ids = expected_token_ids();
            String encontrado = (cur_token.value != null) ? cur_token.value.toString() : sym.terminalNames[cur_token.sym];

            StringBuilder sugerencias = new StringBuilder();
            if (!ids.isEmpty()) {
                sugerencias.append(". Se esperaba: ");
                for (int i = 0; i < ids.size(); i++) {
                    sugerencias.append(traducirToken(sym.terminalNames[ids.get(i)]));
                    if (i < ids.size() - 1) sugerencias.append(", ");
                }
            }

            syntaxErrorList.add(new ErrorAnalisis(
                encontrado,
                cur_token.left,
                cur_token.right,
                "Sintáctico",
                encontrado + "'" + sugerencias.toString()
            ));
        }

        // Método para que el usuario entienda qué falta
        private String traducirToken(String tecnico) {
            switch(tecnico) {
                case "INICIO": return "'INICIO'";
                case "FIN": return "'FIN'";
                case "SEPARADOR": return "el separador '%%%%'";
                case "ID": return "un nombre de variable";
                case "IGUALACION": return "el signo '='";
                case "ENTONCES": return "la palabra 'ENTONCES'";
                case "HACER": return "la palabra 'HACER'";
                case "PARENT_APERTURA": return "'('";
                case "PARENT_CIERRE": return "')'";
                default: return tecnico.toUpperCase();
            }
        }
:}

/*----------------------------------------------------------
                         reglas
-----------------------------------------------------------*/

/* Terminales: tokens que el parser nos retorna */
terminal    PLECA, IGUALACION,
            IGUALDAD, DIFERENTE, MAYOR, MENOR, MAYOR_IGUAL, MENOR_IGUAL,
            AND, OR, NOT,
            SUMA, RESTA,
            MULTIPLICACION, DIVISION,
            SEPARADOR, COMA, DEFAULT,
            COLOR_TEXTO_SI, COLOR_SI, FIGURA_SI, LETRA_SI,
            COLOR_TEXTO_MIENTRAS, COLOR_MIENTRAS, FIGURA_MIENTRAS, LETRA_MIENTRAS, LETRA_SIZE_MIENTRAS,LETRA_SIZE_SI, LETRA_SIZE_BLOQUE,
            COLOR_TEXTO_BLOQUE, COLOR_BLOQUE, FIGURA_BLOQUE, LETRA_BLOQUE,
            INICIO, FIN, VAR, SI, ENTONCES, MIENTRAS, MOSTRAR, LEER, FIN_MIENTRAS, HACER, FIN_SI,
            PARENT_APERTURA, PARENT_CIERRE,
            FIGURA, FUENTE;

/*======Apartado de tipado de tokens que vienen del lexer======*/
terminal String ID, COLOR_HEX;
terminal Double DECIMAL;
terminal Integer ENTERO;
terminal String CADENA;



/* no terminales, reglas que nosotros vamos a definir sintacticamente */
non terminal NodoPrograma programa;
non terminal List seccion_configuracion;
non terminal List lista_configuraciones;
non terminal NodoInstruccion si_simple;
non terminal NodoInstruccion mientras_simple;
non terminal NodoInstruccion declaracion;
non terminal NodoInstruccion asignacion;
non terminal NodoInstruccion mostrar;
non terminal NodoInstruccion leer;

/*===Representacion de una expresion matematica===*/
non terminal NodoExpresion expresion;

/*===Representacion de una expresion matematica===*/



/*No terminales para poder detectar listados completos de bloques de codigo*/

non terminal List lista_sentencias_simples;
non terminal NodoInstruccion sentencia_simple;

non terminal NodoInstruccion estructura;
non terminal List lista_estructuras;

/*Fin de los no terminales para poder detectar listados completos de bloques de codigo*/

/*==Gramatica de personalizacion==*/

non terminal NodoConfiguracion config_estilos;
non terminal NodoColor valor_color;
non terminal NodoRgb rgb_estado;

/*==Fin de la Gramatica de personalizacion==*/


/*====Sub region de estados de personalizacion*/

non terminal NodoConfiguracion config_color;
non terminal NodoConfiguracion config_figura;
non terminal NodoConfiguracion config_fondo;
non terminal NodoConfiguracion config_size_letra;
non terminal NodoConfiguracion config_tipo_letra;


/*====Fin de la region de estados de personalizacion====*/


//===========Gramatica de condiciones==================
non terminal NodoExpresion condicion;
non terminal NodoExpresion condicion_logica;

//===========Fin de la Gramatica de condiciones==================

//===========Presedencia de tipos=====================

precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION;
precedence left OR;
precedence left AND;
precedence right NOT;

//===========Presedencia de tipos=====================

/* Símbolo inicial */
start with programa;


/* Gramatica: reglas para validacion */

programa ::= INICIO lista_estructuras:l FIN seccion_configuracion:c
            {:
                RESULT = new NodoPrograma(l, c);
            :}
            | lista_estructuras:l
            {:
                syntaxErrorList.add(new ErrorAnalisis("Código", lleft, lright, "Sintáctico", "Se detectaron instrucciones pero. Se esperaba (INICIO, FIN y %%%%)."));
                RESULT = new NodoPrograma(l, new ArrayList());
            :}
            | INICIO lista_estructuras:l error:e seccion_configuracion:c
            {:
                syntaxErrorList.add(new ErrorAnalisis("FIN", eleft, eright, "Sintáctico", "Se esperaba la palabra clave 'FIN' para cerrar el bloque de código antes del separador '%%%%'."));
                RESULT = new NodoPrograma(l, c);
            :}
            | lista_estructuras:l FIN seccion_configuracion:c
            {:
                syntaxErrorList.add(new ErrorAnalisis("INICIO", lleft, lright, "Sintáctico", "Falta la palabra clave 'INICIO' al principio del archivo."));
                RESULT = new NodoPrograma(l, c);
            :}
            | lista_estructuras:l seccion_configuracion:c
            {:
                syntaxErrorList.add(new ErrorAnalisis("Estructura", lleft, lright, "Sintáctico", "El programa no tiene 'INICIO' ni 'FIN'. El código debe estar encerrado entre estas palabras."));
                RESULT = new NodoPrograma(l, c);
            :}
            | INICIO lista_estructuras:l FIN
            {:
                syntaxErrorList.add(new ErrorAnalisis("SEPARADOR", lleft, lright, "Sintáctico", "Anomalía fatal: No se encontró el separador '%%%%' ni la sección de configuración al final."));
                RESULT = new NodoPrograma(l, new ArrayList());
            :}
            | error:e
            {:
                syntaxErrorList.add(new ErrorAnalisis("Raiz", eleft, eright, "Sintáctico", "El archivo no tiene una estructura válida de programa. Se esperaba 'INICIO'."));
                RESULT = null;
            :}
            ;

/*===Agrupamiento de sentencias y gramatica principal de reconocimiento====*/
/*lista_sentencias ::= lista_sentencias:list estructura:es
                    {:
                        list.add(es);
                        RESULT = list;
                    :}
                    | estructura: es
                    {:
                        List lista = new ArrayList();
                        lista.add(es);
                        RESULT = lista;
                    :}
                    ;
*/
/*===Agrupamiento de sentencias y gramatica principal de reconocimiento====*/


/*===Agrupamiento de sentencias por bloques====*/

lista_estructuras   ::= lista_estructuras:list estructura:es
                        {:
                            list.add(es);
                            RESULT = list;
                        :}
                        | estructura:es
                        {:
                            List lista = new ArrayList();
                            lista.add(es);
                            RESULT = lista;
                        :}
                        ;



estructura      ::= sentencia_simple:s
                {: RESULT = s; :}
                | si_simple:si
                {: RESULT = si; :}
                | mientras_simple:m
                {: RESULT = m; :}
                ;

/*===Agrupamiento de sentencias por bloques====*/


/*===Reconocimiento de sentencias simples====*/

declaracion     ::= VAR ID:id IGUALACION expresion:e
                {:
                    RESULT = new NodoDeclaracion(id.toString(), e);
                :}
                | VAR ID:id
                {:
                    RESULT = new NodoDeclarado(id.toString());
                :}
                | VAR IGUALACION error:e
                {:
                    syntaxErrorList.add(new ErrorAnalisis("=", eleft, eright, "Sintáctico", "Se esperaba el identificador de la variable después de \"VAR\""));
                    RESULT = null;
                :}
                | VAR ID:id IGUALACION error:e
                {:
                    syntaxErrorList.add(new ErrorAnalisis("=", eleft, eright, "Sintáctico", "Se esperaba un valor o expresión después del '=' al declarar '" + id + "'."));
                    RESULT = new NodoDeclarado(id.toString());
                :}
                ;

asignacion      ::= ID:id IGUALACION expresion:e
                {:
                    RESULT = new NodoAsignacion(id.toString(), e);
                :}
                ;


condicion ::= expresion:e1 IGUALDAD expresion:e2
            {: RESULT = new NodoIgual(e1,e2,e1left,e1right); :}
            | expresion:e1 DIFERENTE expresion:e2
            {: RESULT = new NodoDiferente(e1,e2,e1left,e1right); :}
            | expresion:e1 MAYOR expresion:e2
            {: RESULT = new NodoMayor(e1,e2,e1left,e1right); :}
            | expresion:e1 MENOR expresion:e2
            {: RESULT = new NodoMenor(e1,e2,e1left,e1right); :}
            | expresion:e1 MAYOR_IGUAL expresion:e2
            {: RESULT = new NodoMayorIgual(e1,e2,e1left,e1right); :}
            | expresion:e1 MENOR_IGUAL expresion:e2
            {: RESULT = new NodoMenorIgual(e1,e2,e1left,e1right); :}
            ;

condicion_logica ::= condicion_logica:cl AND condicion:c2
                   {: RESULT = new NodoAnd(cl,c2,clleft,clright); :}
                   | condicion_logica:cl OR condicion:c2
                   {: RESULT = new NodoOr(cl,c2,clleft,clright); :}
                   | NOT condicion_logica:cl
                   {: RESULT = new NodoNot(cl,clleft,clright); :}
                   | condicion:c
                   {: RESULT = c; :}
                   ;

/*===Reconocimiento de sentencias simples====*/

/*===Reconocimiento de expresiones matematicas sin SHIFT REDUCE====*/

expresion ::=   expresion:e1 SUMA expresion:e2 {:RESULT = new NodoSuma(e1,e2,e1left,e1right); :}
                | expresion:e1 RESTA expresion:e2 {:RESULT = new NodoResta(e1, e2,e1left,e1right); :}
                | expresion:e1 MULTIPLICACION expresion:e2 {: RESULT = new NodoMultiplicacion(e1,e2,e1left,e1right); :}
                | expresion:e1 DIVISION expresion:e2 {: RESULT = new NodoDivision(e1,e2,e1left,e1right); :}
                | PARENT_APERTURA expresion:e PARENT_CIERRE {: RESULT = e; :}
                | ENTERO:e {: RESULT = new NodoEntero(e, eleft, eright); :}
                |DECIMAL:d {: RESULT = new NodoDecimal(d,dleft,dright); :}
                |ID:id {: RESULT = new NodoVariable(id.toString(),idleft,idright); :}
                ;

/*===Reconocimiento de expresiones matematicas sin SHIFT REDUCE====*/


/*===Reconocimiento de sentencias que pueden contener varias instrucciones====*/

lista_sentencias_simples ::= lista_sentencias_simples:l sentencia_simple: s
                            {:
                                l.add(s);
                                RESULT = l;
                            :}
                            | sentencia_simple:s
                            {:
                                List lista = new ArrayList();
                                lista.add(s);
                                RESULT = lista;
                            :}
                            ;

sentencia_simple        ::= declaracion:d
                        {: RESULT = d; :}
                        | asignacion:a
                        {: RESULT = a; :}
                        | mostrar:m
                        {: RESULT = m; :}
                        | leer:l
                        {: RESULT = l; :}
                        | error:e
                        {:
                            syntaxErrorList.add(new ErrorAnalisis("Sentencia", eleft, eright, "Sintáctico", "Instrucción no reconocida o mal estructurada."));
                            RESULT = null;
                        :}
                        ;

/*===Reconocimiento de sentencias que pueden contener varias instrucciones====*/


/*===Reconocimiento base de cilos y condicionales====*/

si_simple   ::= SI PARENT_APERTURA condicion_logica:c PARENT_CIERRE ENTONCES lista_sentencias_simples:lista FIN_SI
                {:
                    RESULT = new NodoSi(c, new NodoBloque(lista));
                :}
                | SI error FIN_SI
                {:
                    syntaxErrorList.add(new ErrorAnalisis("SI", 0, 0, "Sintactico", "Estructura de SI mal formada."));
                    RESULT = new NodoSi(null, null);
                :}
                ;

mientras_simple     ::= MIENTRAS PARENT_APERTURA condicion_logica:c PARENT_CIERRE HACER lista_sentencias_simples:list FIN_MIENTRAS
                        {:
                            RESULT = new NodoMientras(c, new NodoBloque(list));
                        :}
                        | MIENTRAS error FIN_MIENTRAS
                        {: RESULT = new NodoMientras(null, null); :}
                        ;

/*===Reconocimiento base de cilos y condicionales====*/

/*===Reconocimiento de salidas y entradas====*/
mostrar             ::=  MOSTRAR expresion:e
                         {:
                            RESULT = new NodoMostrar(e);
                        :}
                        | MOSTRAR CADENA:cad
                        {:
                            RESULT = new NodoMostrarCadena(cad.toString());
                        :}
                        ;

leer                ::= LEER ID:id
                        {:
                            RESULT = new NodoLeer(id.toString(),idleft,idright);
                        :}
                        ;

/*===Reconocimiento de salidas y entradas====*/


/*=====Apartado de gramatica de las configuraciones=====*/

seccion_configuracion   ::= SEPARADOR lista_configuraciones: l
                            {: RESULT = l; :}
                            | SEPARADOR error:e
                            {:
                                syntaxErrorList.add(new ErrorAnalisis("%%%%", eleft, eright, "Sintáctico", "Se requiere al menos una configuración después de '%%%%'"));
                                RESULT = new ArrayList();
                            :}
                            ;

lista_configuraciones ::= lista_configuraciones:l config_estilos:c
                        {:
                            l.add(c);
                            RESULT = l;
                        :}
                        | config_estilos:c
                        {:
                            List lista = new ArrayList();
                            lista.add(c);
                            RESULT = lista;
                        :}
                        | lista_configuraciones:l error
                        {: RESULT = new ArrayList(); :}
                        ;


config_estilos        ::=   DEFAULT IGUALACION expresion:e
                            {: RESULT = new NodoConfigDefault(e); :}
                            | config_color:c
                            {: RESULT = c; :}
                            | config_figura:f
                            {: RESULT = f; :}
                            | config_fondo:f
                            {: RESULT = f; :}
                            | config_size_letra:figura
                            {: RESULT = figura; :}
                            | config_tipo_letra:fuente
                            {: RESULT = fuente; :}
                            ;

/*======Sub region de configuraciones persionalizables*/

/*====Cambia el color de texto de la instruccion====*/

config_color        ::= COLOR_TEXTO_SI IGUALACION valor_color:v PLECA expresion:n
                        {: RESULT = new NodoConfigColor(TipoConfiguracion.INSTRUCCION_SI, v, n); :}
                    | COLOR_TEXTO_MIENTRAS IGUALACION valor_color:v PLECA expresion:n
                        {: RESULT = new NodoConfigColor(TipoConfiguracion.INSTRUCCION_MIENTRAS, v, n); :}
                    | COLOR_TEXTO_BLOQUE IGUALACION valor_color:v PLECA expresion:n
                        {: RESULT = new NodoConfigColor(TipoConfiguracion.INSTRUCCION_BLOQUE, v, n); :}
                    ;

/*====Cambia el color de fondo de la instruccion====*/

config_fondo        ::= COLOR_SI IGUALACION valor_color:v PLECA expresion:n
                        {: RESULT = new NodoConfigFondo(TipoConfiguracion.INSTRUCCION_SI, v, n); :}
                    | COLOR_MIENTRAS IGUALACION valor_color:v PLECA expresion:n
                        {: RESULT = new NodoConfigFondo(TipoConfiguracion.INSTRUCCION_MIENTRAS, v, n); :}
                    | COLOR_BLOQUE IGUALACION valor_color:v PLECA expresion:n
                        {: RESULT = new NodoConfigFondo(TipoConfiguracion.INSTRUCCION_BLOQUE, v, n); :}
                    ;


/*====Cambia la figura de la instruccion====*/

config_figura       ::= FIGURA_MIENTRAS IGUALACION FIGURA:f PLECA expresion:n
                        {: RESULT = new NodoConfigFigura(TipoConfiguracion.INSTRUCCION_MIENTRAS, f.toString(), n); :}
                    | FIGURA_SI IGUALACION FIGURA:f PLECA expresion:n
                        {: RESULT = new NodoConfigFigura(TipoConfiguracion.INSTRUCCION_SI, f.toString(), n); :}
                    | FIGURA_BLOQUE IGUALACION FIGURA:f PLECA expresion:n
                        {: RESULT = new NodoConfigFigura(TipoConfiguracion.INSTRUCCION_BLOQUE, f.toString(), n); :}
                    ;

/*====Cambia el size de la letra de la instruccion====*/

config_size_letra   ::= LETRA_SIZE_MIENTRAS IGUALACION expresion:ex1 PLECA expresion:ex2
                        {: RESULT = new NodoConfigSizeLetra(TipoConfiguracion.INSTRUCCION_MIENTRAS,ex1, ex2); :}
                    | LETRA_SIZE_SI IGUALACION expresion:ex1 PLECA expresion:ex2
                        {: RESULT = new NodoConfigSizeLetra(TipoConfiguracion.INSTRUCCION_SI,ex1, ex2); :}
                    | LETRA_SIZE_BLOQUE IGUALACION expresion:ex1 PLECA expresion:ex2
                        {: RESULT = new NodoConfigSizeLetra(TipoConfiguracion.INSTRUCCION_BLOQUE,ex1, ex2); :}
                    ;

/*====Cambia la fuente de la instruccion====*/

config_tipo_letra   ::= LETRA_MIENTRAS IGUALACION FUENTE:fuente PLECA expresion:n
                        {: RESULT = new NodoConfigTipoLetra(TipoConfiguracion.INSTRUCCION_MIENTRAS, fuente.toString(), n); :}
                    | LETRA_SI IGUALACION FUENTE:fuente PLECA expresion:n
                        {: RESULT = new NodoConfigTipoLetra(TipoConfiguracion.INSTRUCCION_SI, fuente.toString(), n); :}
                    | LETRA_BLOQUE IGUALACION FUENTE:fuente PLECA expresion:n
                        {: RESULT = new NodoConfigTipoLetra(TipoConfiguracion.INSTRUCCION_BLOQUE, fuente.toString(), n); :}
                    ;

/*====Instrucciones que permiten extraer el valor del color====*/

valor_color         ::= rgb_estado:rg
                    {: RESULT = rg; :}
                    | COLOR_HEX:he
                    {: RESULT = new NodoHexColor(he); :}
                    ;

/*====Instrucciones que permiten extraer el valor de un color RGB====*/

rgb_estado          ::= expresion:r1 COMA expresion:r2 COMA expresion:r3
                        {: RESULT = new NodoRgb(r1, r2, r3); :}
                        ;

/*Created by Pablo*/




